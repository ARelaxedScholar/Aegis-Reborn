use crate::evolution::Genome;
use crate::evolution::grammar::Grammar;
use crate::strategy::Strategy;
use crate::vm::op::{DynamicConstant, IndicatorType, Op, PriceType};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum MappingError {
    #[error(
        "Invalid grammar: non-terminal '{non_terminal}' has no production rules. Genome: {genome:?}"
    )]
    MissingProduction {
        non_terminal: String,
        genome: Genome,
    },
    #[error("Grammar recursion depth limit ({limit}) exceeded. Genome: {genome:?}")]
    DepthLimitExceeded { limit: u32, genome: Genome },
    #[error("Program exceeded max token limit of {limit}. Genome: {genome:?}")]
    TokenLimitExceeded { limit: usize, genome: Genome },
}

/// Struct that keeps information about the information
/// relating to the mapping of a given genome
struct MappingContext<'a> {
    /// Reference to the `Genome` to map
    genome: &'a Genome,
    /// Current index to be map for `Strategy`
    codon_idx: usize,
    /// Current number of tokens in the `Strategy`
    token_count: usize,
    /// Current recursion depth
    recursion_depth: u32,
}


impl<'a> MappingContext<'a> {
    /// Creates a new `MappingContext`
    ///
    /// # Arguments
    /// * `genome` - Reference to a `Genome` struct representing the genome to map to a `Strategy` 
    ///
    /// # Returns
    /// `MappingContext`
    fn new(genome: &'a Genome) -> Self {
        Self {
            genome,
            codon_idx: 0,
            token_count: 0,
            recursion_depth: 0,
        }
    }

    /// This function returns the next codon to map, with wrapping if the genome is not long
    /// enough.
    ///
    /// This method mutably borrows the `MappingContext` instance,
    /// modifying its `codon_idx` field after each call to the function.
    ///
    /// # Arguments
    /// * `&mut self` - Reference to a `Genome` struct representing the genome to map to a `Strategy` 
    ///
    /// # Returns
    /// `u32` - the `u32` codon to be mapped
    fn next_codon(&mut self) -> u32 {
        if self.genome.is_empty() {
            return 0;
        }
        let codon = self.genome[self.codon_idx];
        self.codon_idx = (self.codon_idx + 1) % self.genome.len();
        codon
    }
}

/// This struct maps (you don't say) the genome into a `Strategy` struct.
/// The `max_tokens` allowed for a given genome, and the `max_recursion_depth` to allow when
/// mapping.
pub struct GrammarBasedMapper<'a> {
    /// The `Grammar` to be used for the mapping
    grammar: &'a Grammar,
    /// Max allowable token count for a given strategy
    max_tokens: usize,
    /// Max allowable recursion depth (to avoid infinite recursions)
    max_recursion_depth: u32,
}

impl<'a> GrammarBasedMapper<'a> {
    /// Creates a new `GrammarBasedMapper`
    ///
    /// # Arguments
    /// * `grammar` - Reference to the `Grammar` that will be used for the mapping
    /// * `max_tokens` - Maximum number of tokens allowed for a given genome 
    /// * `max_recursion_depth` - Maximum recursion depth allowed during the mapping process
    ///
    /// # Returns
    /// * `Self` - An instance of the EvolutionEngine struct
    pub fn new(grammar: &'a Grammar, max_tokens: usize, max_recursion_depth: u32) -> Self {
        Self {
            grammar,
            max_tokens,
            max_recursion_depth,
        }
    }

    /// The main orchestrator for the `GrammarBasedMapper`
    /// Delegates actual expansion (token mapping) to `expand`, but it handles the rest
    ///
    /// # Arguments
    /// * `&self` - Reference to `GrammarBasedMapper`
    /// * `genome` - The genome that must be turned into an actual program 
    ///
    /// # Returns
    /// * `Result<Strategy, MappingError>` 
    pub fn map(&self, genome: &Genome) -> Result<Strategy, MappingError> {
        let mut context = MappingContext::new(genome);
        let mut programs = HashMap::new();

        let mut bytecode = Vec::new();
        self.expand("<start>", &mut context, &mut bytecode)?;

        // This logic correctly splits the generated bytecode stream into separate programs.
        let mut current_program_name: Option<String> = None;
        let mut current_program_code: Vec<Op> = Vec::new();

        for op in bytecode {
            match op {
                Op::EntryMarker => {
                    if let Some(name) = current_program_name.take() {
                        if !current_program_code.is_empty() {
                            programs.insert(name, current_program_code);
                        }
                    }
                    current_program_name = Some("entry".to_string());
                    current_program_code = Vec::new();
                }
                Op::ExitMarker => {
                    if let Some(name) = current_program_name.take() {
                        if !current_program_code.is_empty() {
                            programs.insert(name, current_program_code);
                        }
                    }
                    current_program_name = Some("exit".to_string());
                    current_program_code = Vec::new();
                }
                _ => {
                    current_program_code.push(op);
                }
            }
        }

        if let Some(name) = current_program_name {
            if !current_program_code.is_empty() {
                programs.insert(name, current_program_code);
            }
        }

        Ok(Strategy { programs })
    }

    /// This function takes care of transforming a symbol into
    /// either some other token or a non-terminal.
    ///
    /// # Arguments
    /// * `&self` - Reference to `GrammarBasedMapper`
    /// * `symbol` - The genome that must be turned into an actual program 
    /// * `context` - A mutable reference to `MappingContext` which keeps track of the current
    /// `recursion_depth` and `token_count`
    /// * `bytecode` - A mutable reference to the `Vec<Op>` representing this program's code
    ///
    /// # Returns
    /// * `Result<(), MappingError>` 
    fn expand(
        &self,
        symbol: &str,
        context: &mut MappingContext,
        bytecode: &mut Vec<Op>,
    ) -> Result<(), MappingError> {
        if context.token_count >= self.max_tokens {
            return Err(MappingError::TokenLimitExceeded {
                limit: self.max_tokens,
                genome: context.genome.clone(),
            });
        }
        if context.recursion_depth >= self.max_recursion_depth {
            return Err(MappingError::DepthLimitExceeded {
                limit: self.max_recursion_depth,
                genome: context.genome.clone(),
            });
        }

        context.recursion_depth += 1;

        if self.grammar.is_non_terminal(symbol) {
            let productions =
                self.grammar
                    .rules
                    .get(symbol)
                    .ok_or_else(|| MappingError::MissingProduction {
                        non_terminal: symbol.to_string(),
                        genome: context.genome.clone(),
                    })?;

            let choice = context.next_codon() as usize % productions.len();
            let expansion = &productions[choice];

            for s in expansion {
                self.expand(s, context, bytecode)?;
            }
        } else {
            // Translate terminal into an Op or a placeholder
            match symbol {
                "ENTRY" => bytecode.push(Op::EntryMarker), 
                "EXIT" => bytecode.push(Op::ExitMarker), 
                _ => {
                    if let Some(op) = self.terminal_to_op(symbol) {
                        bytecode.push(op);
                        context.token_count += 1;
                    }
                }
            }
        }

        context.recursion_depth -= 1;
        Ok(())
    }

    /// This function is just a huge match statement which takes care
    /// of associating given (terminal) symbols to their equivalent `vm::Op` code
    /// 
    /// # Arguments
    /// * `&self` - Reference to `GrammarBasedMapper`
    /// * `terminal` - String slice representing the terminal symbol to map
    ///
    /// # Returns
    /// * `Option<Op>` 
    fn terminal_to_op(&self, terminal: &str) -> Option<Op> {
        match terminal {
            "ADD" => Some(Op::Add),
            "SUB" => Some(Op::Subtract),
            "MUL" => Some(Op::Multiply),
            "DIV_SAFE" => Some(Op::Divide),
            "GT" => Some(Op::GreaterThan),
            "LT" => Some(Op::LessThan),
            "GE" => Some(Op::GreaterThanOrEqual),
            "LE" => Some(Op::LessThanOrEqual),
            "EQ" => Some(Op::Equal),
            "AND" => Some(Op::And),
            "OR" => Some(Op::Or),
            "NOT" => Some(Op::Not),
            "CLOSE" => Some(Op::PushPrice(PriceType::Close)),
            "OPEN" => Some(Op::PushPrice(PriceType::Open)),
            "HIGH" => Some(Op::PushPrice(PriceType::High)),
            "LOW" => Some(Op::PushPrice(PriceType::Low)),
            "SMA20" => Some(Op::PushIndicator(IndicatorType::Sma(20))),
            "SMA100" => Some(Op::PushIndicator(IndicatorType::Sma(100))),
            "RSI14" => Some(Op::PushIndicator(IndicatorType::Rsi(14))),
            "CLOSE_P1" => Some(Op::PushDynamic(DynamicConstant::ClosePercent(1))),
            "CLOSE_M1" => Some(Op::PushDynamic(DynamicConstant::ClosePercent(-1))),
            "SMA20_P2" => Some(Op::PushDynamic(DynamicConstant::SmaPercent(20, 2))),
            "SMA20_M2" => Some(Op::PushDynamic(DynamicConstant::SmaPercent(20, -2))),
            c => c.parse::<f64>().ok().map(Op::PushConstant),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::evolution::grammar::Grammar;
    use std::fs::File;
    use std::io::Write;
    use tempfile::tempdir;

    fn grammar_from_str(grammar_str: &str) -> Grammar {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.bnf");
        let mut file = File::create(&file_path).unwrap();
        write!(file, "{}", grammar_str).unwrap();
        Grammar::new(&file_path).unwrap()
    }

    #[test]
    fn test_optional_exit_is_respected() {
        let grammar = grammar_from_str(
            "
            <start> ::= <entry_program> <optional_exit>
            <entry_program> ::= ENTRY 1.0
            <optional_exit> ::= | <exit_program>
            <exit_program> ::= EXIT 0.0
        ",
        );
        let mapper = GrammarBasedMapper::new(&grammar, 50, 256);

        // Codon consumption:
        // 1st codon for <start> (trivial choice)
        // 2nd codon for <entry_program> (trivial choice)
        // 3rd codon for <optional_exit> (choice 0 -> empty, choice 1 -> <exit_program>)

        // To get no exit program, the 3rd codon consumed must be 0 (or an even number).
        // The original `vec![0, 0]` works because the 3rd access wraps around to the first element.
        let genome_no_exit: Genome = vec![0, 0];
        let strategy_no_exit = mapper.map(&genome_no_exit).unwrap();
        assert!(strategy_no_exit.programs.contains_key("entry"));
        assert!(!strategy_no_exit.programs.contains_key("exit"));

        // To get an exit program, the 3rd codon consumed must be 1 (or an odd number).
        // The original `vec![0, 1]` failed because the 3rd codon was `0` (due to wrap-around).
        // This new genome ensures the choice for <optional_exit> is 1.
        let genome_with_exit: Genome = vec![0, 0, 1];
        let strategy_with_exit = mapper.map(&genome_with_exit).unwrap();
        assert!(strategy_with_exit.programs.contains_key("entry"));
        assert!(strategy_with_exit.programs.contains_key("exit"));
        assert_eq!(
            strategy_with_exit.programs.get("exit").unwrap(),
            &vec![Op::PushConstant(0.0)]
        );
    }

    #[test]
    fn test_token_limit_enforced() {
        let grammar = grammar_from_str(
            "
            <start> ::= <entry_program>
            <entry_program> ::= ENTRY <long_expr>
            <long_expr> ::= 1.0 1.0 ADD 1.0 ADD 1.0 ADD 1.0 ADD
        ",
        );
        let mapper = GrammarBasedMapper::new(&grammar, 3, 256); // Very small limit

        let genome: Genome = vec![0, 0];
        let result = mapper.map(&genome);

        assert!(matches!(
            result,
            Err(MappingError::TokenLimitExceeded { .. })
        ));
        if let Err(MappingError::TokenLimitExceeded {
            limit,
            genome: err_genome,
        }) = result
        {
            assert_eq!(limit, 3);
            assert_eq!(err_genome, genome);
        }
    }
}
