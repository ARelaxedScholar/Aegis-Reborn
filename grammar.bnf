# ============================================================================
# Golden Aegis Grammar Definition (BNF)
# ============================================================================
#
# This file defines the language of trading strategies that the evolutionary
# algorithm can explore. The grammar is written in Backus‑Naur Form (BNF).
#
# How to extend the grammar:
# 1. Add a new terminal symbol (e.g., a new indicator) under `<indicator>` or
#    `<price>` or define a new operand type.
# 2. Implement the corresponding computation in `src/evaluation/indicators.rs`.
# 3. Add the bytecode operation in `src/vm/op.rs` and implement its execution
#    in `src/vm/engine.rs`.
# 4. Update the mapper (`src/evolution/mapper.rs`) to handle the new symbol.
#
# The grammar is deliberately minimal during the "Crawl" phase. New constructs
# (e.g., nested IF/THEN/ELSE, stop‑losses, position sizing) will be added in
# the "Walk" and "Run" phases.
#
# ----------------------------------------------------------------------------
# Root
# ----------------------------------------------------------------------------
# A strategy MUST have an entry program. The exit program is optional.
<start> ::= <entry_program> <optional_exit>

# --- Program Definitions ---
<entry_program> ::= ENTRY <boolean_expr>
<exit_program>  ::= EXIT <boolean_expr>

# --- Optionality Wrapper ---
<optional_exit> ::= | <exit_program>

# --- Expressions ---
<boolean_expr> ::= <arithmetic_expr> <arithmetic_expr> <comparator> | <boolean_expr> <boolean_expr> <logical_op> | <boolean_expr> NOT
<arithmetic_expr> ::= <operand> | <arithmetic_expr> <arithmetic_expr> <arithmetic_op>

# --- Operators (Terminals) ---
<comparator> ::= GT | LT | GE | LE
<logical_op> ::= AND | OR
<arithmetic_op> ::= ADD | SUB | MUL | DIV_SAFE

# --- Operands (Data Terminals) ---
# Operands are now split into more specific types for clarity.
<operand> ::= <indicator> | <price> | <dynamic_constant> | <static_constant>

# Static, absolute constants, useful for RSI levels, etc.
# Next target for optimization, the grammar is too simple.
<static_constant> ::= -1.0 | 0.0 | 1.0 | 30.0 | 50.0 | 70.0 | 100.0 | 10000.0 | 20000.0 | 30000.0 | 40000.0 | 50000.0 | 60000.0

# Dynamic, relative constants, crucial for high-value assets.
<dynamic_constant> ::= CLOSE_P1 | CLOSE_M1 | SMA20_P2 | SMA20_M2

# Technical indicators. To add a new indicator:
# 1. Add its symbol here (e.g., | EMA12 | MACD | etc.)
# 2. Implement its computation in `src/evaluation/indicators.rs`.
# 3. Add the corresponding bytecode operation in `src/vm/op.rs` and implement
#    its execution in `src/vm/engine.rs`.
# 4. Update the mapper (`src/evolution/mapper.rs`) to recognize the new symbol.
# Note: Both old-style (SMA20) and new-style (SMA(20)) syntax are supported.
<indicator> ::= SMA20 | SMA50 | SMA100 | SMA200 | EMA20 | EMA50 | EMA100 | EMA200 | RSI14 | RSI30 | SMA(20) | SMA(50) | SMA(100) | SMA(200) | EMA(20) | EMA(50) | EMA(100) | EMA(200) | RSI(14) | RSI(30)

# Price series available for comparison.
<price> ::= OPEN | HIGH | LOW | CLOSE
